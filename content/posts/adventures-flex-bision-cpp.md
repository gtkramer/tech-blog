---
title: "Adventures Using Flex and Bison with C++"
date: 2018-01-13T15:32:00-07:00
tags: ["bison", "flex", "c++", "parser", "lexer", "stl"]
draft: false
---

## Motivation and Goal

The compilers class I took as an undergraduate at the University of Connecticut is the most challenging yet one of the most interesting classes I have ever taken.  The project-driven class gave students hands-on experience with writing a compiler by breaking the large task into smaller tasks over the course of the semester.  Specifically, we needed to write a compiler that translates C\-\-, a simple subset of C, to LLVM IR.  From there, we used the LLVM toolchian to finish compiling our generated LLVM IR to machine code.

To help with the scanner and the parser bits that are essential to any compiler, we used the GNU tools flex and bison.  These are time-tested tools known for not requiring any additional runtime or build requirements for the code they generate.  In this sense, the code they generate for doing the actual text processing is portable.  These tools are also mature with many years of development behind them, which makes them not a bad choice.

I wanted to revisit my knowledge of flex and bison with [a program](https://github.com/gtkramer/ScaffoldingGenerator) I'm developing outside of work.  The goal of the program is to generate the scaffolding for a model before everything is 3D printed and to provide a means for graphically interacting with the computed result.  The model is given to the program in the form of either a text or binary STL file.  I wanted to see if I could write a C++ parser for a text STL file using flex and bison.  The syntax for a text STL file is very simple.  It's given below:

``` plain
solid name
	facet normal ni nj nk
		outer loop
			vertex v1x v1y v1z
			vertex v2x v2y v2z
			vertex v3x v3y v3z
		endloop
	endfacet
endsolid name
```

I became interested in the C++ interface for flex and bison because I wanted to use the vector container from the Standard Template Library to read text STL files as streams.  Previous versions of bison used a union interface which only allows tokens and semantic values to be defined with trivial data types (unless pointers are used).  Bison 3.0 introduced a variant interface which allows complex data types to be used.  Suddenly, it was possible to define tokens and semantic values as follows:

``` c++
%token <float> FLOAT
%type <std::array<std::array<float, 3>, 4>> facet
```

These are natural definitions analogous to the structure of the STL file format.  I figured I would try to get on board with the variant interface in conjunction with the C++ interface for flex and bison.  While I was at it, I wanted to see if I could also make a pure (reentrant) scanner and parser.

## Bison C++ Thoughts

I began looking through the GNU documentation for guidance on how to use the variant and C++ interfaces with bison.  I found [a complete C++ example](https://www.gnu.org/software/bison/manual/html_node/Calc_002b_002b-Parser.html) to help me get going.

To configure bison in a good manner and to use the variant and C++ interfaces, the following declarations are required:

``` c++
%skeleton "lalr1.cc"
%require "3.5"
%defines
%define api.token.constructor
%define api.value.type variant
%define parse.assert
```

For grammar actions to use the Standard Template Library, they need to have detailed knowledge about the driver, which orchestrates the parsing from the main program.  But the generated parser code also needs to have detailed knowledge of the driver.  This requires the following code:

``` c++
%code requires {
    #include <array>
    #include <vector>
    class StlTextDriver;
}

%code {
    #include "StlTextDriver.h"
}
```

After getting going, I ran into the same uncomfortable usage of bison that I remember seeing back when I was taking my compilers class with code being mixed with declarative syntax in different sections.  In addition, needing to worry about this circular dependency as a part of the grammar definition feels like an extra step.  And needing to define options to assert proper usage of the variant interface and to fully benefit from type safety also feels a little ugly.  It made me begin to question the quality of the code generated by bison, but I wanted to see this through, so I moved on to take a look at flex.

## Flex C++ Challenges

As with bison, I looked through the GNU documentation for guidance on how to use the C++ interface with flex with the same [complete C++ example](https://www.gnu.org/software/bison/manual/html_node/Calc_002b_002b-Scanner.html#Calc_002b_002b-Scanner).  I found some [additional GNU documentation](https://ftp.gnu.org/old-gnu/Manuals/flex-2.5.4/html_node/flex_19.html) to be particularly useful here.

To use the C++ interface of flex, the following declaration is required:

``` C++
%option c++
```

When I tried to compile the generated scanner code, I received an error about a missing definition of `YY_NULLPTR`.  This looked like a bug in flex to me.  To work around it, I defined it manually in a manner consistent with the C++11 standard:

``` c++
#ifndef YY_NULLPTR
	#define YY_NULLPTR nullptr
#endif
```

Out of curiosity, I decided to take a look at the generated scanner code.  To my surprise, I was immediately greeted with the following message:

``` c++
/* The c++ scanner is a mess. The FlexLexer.h header file relies on the
* following macro. This is required in order to pass the c++-multiple-scanners
* test in the regression suite. We get reports that it breaks inheritance.
* We will address this in a future release of flex, or omit the C++ scanner
* altogether.
*/
```

*giggle*

While at the end of the day I found this comment to be a comical reminder that no software is perfect, it became clear that mature code does not necessarily equal quality code.  At this point, I was about ready to give up on flex and bison.

## Nail in the Coffin

I took a look at what technical literature had to say about flex and bison to see if I could confirm my findings.  O'Rielly is a respected technical publisher and I see many of their books at my workplace on my coworkers' shelves.  Their book *Flex and Bison* was published in 2009, which is a little dated, but maybe not so bad given the rate at which these tools change.  After reading through a couple of the chapters, I found some telling commentary:

> Unfortunately, as of the time this book went to press (mid-2009), the code for flex pure scanners and yacc pure scanners is a mess. Bison’s calling sequence for a pure yylex() is different from flex’s, and the way they handle per-instance data is different. It’s possible to paper over the problems in the existing code and persuade pure scanners and parsers to work together, which is what we will do in this chapter, but before doing so, check the latest flex and bison documentation.

> As should be apparent by now, the C++ support in bison is nowhere near as mature as the C support, which is not surprising since it’s about 30 years newer.

## Where to Now?

Given it has been difficult to work with low quality code, as I still didn't have a working parser generated for a text STL file, I decided to drop flex and bison and look at alternative options.  I didn't want to drop a parsing solution altogether and just use regular expressions because they are not the easiest to maintain and they are more error-prone than using tools that guarantee good use.  Lemon, Boost Spirit, and ANTLR all look like intersting options.

Nonetheless, all I have left to say is, "So long, farewell, auf wiedersehen, goodbye, flex and bison!"
